# 文档处理服务说明文档

## 1. 服务概述

文档处理服务是一个完整的文档处理解决方案，能够将多种格式的文档（如.docx、.pdf等）转换为结构化的JSON格式。服务整合了三个核心处理模块：

1. **文档转换模块**：将各种格式文档转换为Markdown格式
2. **文本分块模块**：将Markdown文档按语义分割成文本块
3. **数据合并模块**：将文本块与图片信息合并为最终的JSON结构

## 2. 技术架构

### 2.1 核心组件
- **Web框架**：Flask
- **文档处理库**：markitdown
- **PDF处理库**：PyMuPDF
- **容器化**：Docker

### 2.2 目录结构
```
document-processor/
├── app.py                 # 主服务应用
├── convert_doc_to_md.py   # 文档转换模块
├── text_chunker.py        # 文本分块模块
├── merge_json_files.py    # 数据合并模块
├── requirements.txt       # Python依赖
├── Dockerfile            # Docker配置
├── docker-compose.yml    # Docker编排配置
├── start.sh              # 启动脚本
├── deploy.sh             # 部署脚本
├── conversion_config.json # 转换配置
├── chunk_config.json     # 分块配置
├── merge_config.json     # 合并配置
├── raw_data/             # 原始文档目录
├── uploads/              # 上传文件目录
├── processed/            # 处理结果目录
└── temp/                 # 临时文件目录
```

## 3. 环境配置

### 3.1 系统要求
- Python 3.10或以上版本
- Conda环境（推荐使用`dl`环境）
- 至少4GB内存
- Docker和Docker Compose（用于容器化部署）

### 3.2 依赖安装
```bash
# 激活conda环境
conda activate dl

# 安装基础依赖
pip install -r requirements.txt

# 安装文档处理额外依赖
pip install markitdown[docx,pdf]
```

## 4. 部署方式

### 4.1 直接运行
```bash
# 启动服务
python app.py
```

### 4.2 Docker容器化部署

#### 4.2.1 使用Docker Compose部署（推荐）
```bash
# 使用部署脚本（自动创建目录、构建镜像并启动服务）
./deploy.sh

# 或手动部署
# 创建必要的目录
mkdir -p uploads processed temp

# 构建镜像
docker-compose build

# 启动服务
docker-compose up -d
```

#### 4.2.2 使用Docker命令部署
```bash
# 构建镜像
docker build -t document-processor .

# 运行容器
docker run -p 5000:5000 \
  -v $(pwd)/uploads:/app/uploads \
  -v $(pwd)/processed:/app/processed \
  -v $(pwd)/temp:/app/temp \
  document-processor
```

#### 4.2.3 验证部署
```bash
# 检查服务状态
docker-compose ps

# 查看服务日志
docker-compose logs

# 健康检查
curl http://localhost:5000/health
```

## 5. 服务配置

### 5.1 文档转换配置 (conversion_config.json)
```json
{
    "default_input_path": "raw_data",
    "default_output_path": "converted_data"
}
```

### 5.2 文本分块配置 (chunk_config.json)
```json
{
    "chunk_min_length": 10,
    "chunk_max_length": 150,
    "overlap_min_length": 10,
    "overlap_max_length": 50,
    "semantic_patterns": [
        "\\n#{1,6} ",
        "\\n###+",
        "\\n\\n\\*\\*[^\\n]+\\*\\*\\n",
        "\\n\\n[A-Z][^\\n]*\\n\\n"
    ],
    "enable_overlap": false,
    "save_chunk_index": true,
    "chunk_index_filename": "chunk_index.json",
    "default_input_path": "converted_data",
    "default_output_path": "sliced_data",
    "chunking_method": "semantic",
    "chunk_by_length": {
        "enabled": false,
        "chunk_size": 100,
        "chunk_overlap": 20
    },
    "chunk_by_paragraph": {
        "enabled": false,
        "max_chunk_size": 500
    }
}
```

### 5.3 数据合并配置 (merge_config.json)
```json
{
    "default_input_converted_path": "converted_data",
    "default_input_sliced_path": "sliced_data",
    "default_output_path": "merged_data",
    "enable_base64_processing": true,
    "save_merged_index": false,
    "merged_index_filename": "merged_index.json"
}
```

## 6. API接口详解

### 6.1 健康检查接口
- **URL**：`/health`
- **方法**：GET
- **描述**：检查服务是否正常运行
- **响应示例**：
```json
{
  "status": "healthy",
  "timestamp": "2023-07-19T10:30:00.123456"
}
```

### 6.2 单文档处理接口
- **URL**：`/api/v1/process-document`
- **方法**：POST
- **描述**：上传并处理单个文档
- **参数**：
  - `file`：要处理的文档文件
- **响应示例**：
```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "completed",
  "result_file": "document/result.json",
  "download_url": "/api/v1/download/550e8400-e29b-41d4-a716-446655440000/document%2Fresult.json"
}
```

### 6.3 批量文档处理接口
- **URL**：`/api/v1/batch-process`
- **方法**：POST
- **描述**：上传并批量处理多个文档
- **参数**：
  - `files`：要处理的文档文件列表
- **响应示例**：
```json
{
  "task_id": "660e8400-e29b-41d4-a716-446655440001",
  "status": "completed",
  "result_files": ["doc1/result.json", "doc2/result.json"],
  "download_urls": [
    "/api/v1/download/660e8400-e29b-41d4-a716-446655440001/doc1%2Fresult.json",
    "/api/v1/download/660e8400-e29b-41d4-a716-446655440001/doc2%2Fresult.json"
  ]
}
```

### 6.4 下载结果接口
- **URL**：`/api/v1/download/<task_id>/<filename>`
- **方法**：GET
- **描述**：下载处理结果文件
- **参数**：
  - `task_id`：任务ID
  - `filename`：结果文件路径（需要进行URL编码，路径分隔符`/`编码为`%2F`）

## 7. 使用示例

### 7.1 命令行使用
```bash
# 处理单个文档
curl -X POST -F "file=@document.docx" http://localhost:5000/api/v1/process-document

# 批量处理文档
curl -X POST \
  -F "files=@doc1.docx" \
  -F "files=@doc2.pdf" \
  http://localhost:5000/api/v1/batch-process

# 下载结果（注意路径分隔符需要URL编码）
curl -o result.json "http://localhost:5000/api/v1/download/{task_id}/document%2Fresult.json"
```

### 7.2 Python客户端示例
```python
import requests
import json
from urllib.parse import quote

# 服务地址
BASE_URL = "http://localhost:5000"

def process_single_document(file_path):
    """处理单个文档"""
    with open(file_path, 'rb') as f:
        files = {'file': f}
        response = requests.post(f"{BASE_URL}/api/v1/process-document", files=files)
    
    if response.status_code == 200:
        result = response.json()
        print(f"任务ID: {result['task_id']}")
        print(f"结果文件: {result['result_file']}")
        return result
    else:
        print(f"处理失败: {response.text}")
        return None

def download_result(task_id, filename, save_path):
    """下载处理结果"""
    # URL编码文件名
    encoded_filename = quote(filename)
    response = requests.get(f"{BASE_URL}/api/v1/download/{task_id}/{encoded_filename}")
    
    if response.status_code == 200:
        with open(save_path, 'wb') as f:
            f.write(response.content)
        print(f"文件已保存到: {save_path}")
    else:
        print(f"下载失败: {response.text}")

# 使用示例
if __name__ == "__main__":
    # 处理单个文档
    result = process_single_document("test.docx")
    if result:
        # 下载结果
        download_result(result['task_id'], result['result_file'], "result.json")
```

## 8. 错误处理

### 8.1 常见错误码
- `400 Bad Request`：请求参数错误
- `413 Request Entity Too Large`：文件大小超过限制（默认50MB）
- `500 Internal Server Error`：服务器内部错误

### 8.2 错误响应格式
```json
{
  "error": "错误描述信息"
}
```

## 9. 注意事项

1. **文件大小限制**：默认限制上传文件大小为50MB，可在[app.py](file:///home/lynn/projects/filesfromWork/new_project/readFile/demo/app.py)中调整`MAX_CONTENT_LENGTH`参数
2. **支持的文件类型**：目前支持 `txt`, `pdf`, `docx`, `doc`, `html`, `htm`, `pptx`, `xlsx` 格式
3. **中文文件名**：处理包含中文的文件名时，请确保正确进行URL编码
4. **结果保留**：处理结果会保存在[processed](file:///home/lynn/projects/filesfromWork/new_project/readFile/demo/processed)目录中，每个文档有独立文件夹，文件夹内包含[result.json](file:///home/lynn/projects/filesfromWork/new_project/readFile/demo/result.json)文件
5. **路径编码**：下载文件时，路径中的`/`需要编码为`%2F`

## 10. 性能优化建议

1. **并发处理**：对于大量文件处理，建议使用消息队列（如Celery）实现异步处理
2. **缓存机制**：对于重复处理相同文件的请求，可以实现缓存机制
3. **负载均衡**：在生产环境中，可以通过Nginx等实现负载均衡
4. **存储优化**：对于大量文件处理，建议使用云存储服务（如AWS S3）

## 11. 故障排除

### 11.1 常见问题
1. **无法导入markitdown包**：
   ```bash
   pip install markitdown[docx,pdf]
   ```

2. **Flask模块未找到**：
   ```bash
   pip install Flask Werkzeug
   ```

3. **处理失败**：
   - 检查文件格式是否支持
   - 检查文件大小是否超过限制
   - 查看服务日志获取详细错误信息

### 11.2 日志查看
```bash
# 查看服务日志
docker-compose logs -f

# 查看特定服务日志
docker-compose logs -f document-processor
```

## 12. 维护与升级

### 12.1 服务重启
```bash
# 停止服务
docker-compose down

# 启动服务
docker-compose up -d
```

### 12.2 版本升级
1. 备份配置文件
2. 拉取最新代码
3. 重新构建镜像
4. 重启服务
```bash
# 拉取最新代码
git pull

# 重新构建镜像
docker-compose build

# 重启服务
docker-compose down
docker-compose up -d
```

### 12.3 数据清理
```bash
# 清理临时文件
rm -rf temp/*

# 清理处理结果（谨慎操作）
rm -rf processed/*

# 清理上传文件（谨慎操作）
rm -rf uploads/*
```

通过这份详细的说明文档，用户可以快速了解和使用文档处理服务，无论是进行开发、部署还是日常维护都能找到相应的指导信息。